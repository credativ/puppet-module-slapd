
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>RDoc Documentation</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
</head>
<body>
<h2>File: README.rdoc</h2>
<table>
  <tr><td>Path:</td><td>README.rdoc</td></tr>
  <tr><td>Modified:</td><td>Wed Aug 08 11:29:12 +0200 2012</td></tr>
</table>

<h1>credativ puppet module template</h1>
<p>
This is a template for a module in the style of most credativ modules. It
uses parameterized classes and params_lookup to support multiple backends
for parameters (e.g. included params file and hiera).
</p>
<h2>Template usage</h2>
<p>
In order to use the template for a new module, copy the whole template
directory to a new folder with the desired name. Then proceed as following:
</p>
<ol>
<li>Replace <em>module</em> in manifests/*.pp and examples/* with the intended
module name. Example:

<pre>
  sed -i 's/__module__/your_intended_modulename/g' manifests/*.pp examples/*
</pre>
</li>
<li>Edit and add files as needed.

</li>
<li>Make sure the main class has defaults for its parameters in
manifests/params.pp

</li>
<li>Make sure to add proper documentation to all directly used classes and
replace this README with a file documenting the module and its usage.

</li>
</ol>
<h2>Module usage</h2>
<p>
This part describes the usage of modules created with this template. Its
probably best used as a template for your own documentation.
</p>
<h3>Requirements</h3>
<p>
This module template requires the params_lookup function as found in the
example42 puppi module (<a
href="https://github.com/credativ/puppet-example42lib">github.com/credativ/puppet-example42lib</a>)
</p>
<h3>Usage</h3>
<p>
This module template uses parameterized classes. However, to make it work
well with ENCs and to support hiera as an external data store, it uses a
special function to define defaults for each parameter. That way, there are
several ways to feed parameters into classes created with this module.
</p>
<h4>Top-Level variables / Hiera</h4>
<p>
In this case the argument name in the class needs to be prefixed with the
module name. For example, if a module has a parameter use_xy it can be
pre-declared like this:
</p>
<pre>
    $modulename_use_xy = $value
</pre>
<p>
The same naming scheme works if parameters are defined in hiera.
</p>
<p>
Just <b>be</b> <b>aware</b> of global parameters: Modules may declare a
parameter as global. In this case it is not prefixed with the module name.
That usually makes sense for variables which are shared between various
different modules.
</p>
<h4>Parameters</h4>
<p>
Obviously passing the plain parameters as argument to the class definition
works too:
</p>
<pre>
    class { 'modulename':
        use_xy =&gt; $value
    }
</pre>
<p>
In that case no prefixing with the module name is required.
</p>
<h4>Defaults</h4>
<p>
If no value is specified, in none of the mentioned data sources, modules
refer to default values. Those are defined in modulename::params
(manifests/params.pp). Each module shall define the most sensible defaults.
</p>







<h2>Classes</h2>
</body>
</html>
Files:   1
Classes: 0
Modules: 0
Methods: 0
Elapsed: 0.050s
